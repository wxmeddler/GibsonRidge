#!/usr/bin/env python
# coding: utf-8

import datetime
import pandas as pd

#Setting up inputs
print('To use this script, go to https://www.spotternetwork.org/positions/history, login, and download your positions.\n' +
     'Note: pandas must be installed / in evironment to run this script.')
positionsloc = input('Enter the path to the positions text file you downloaded:')

#Reading Positions CSV file
df = pd.read_csv(positionsloc)
print('Reading....')

#Pre-Processing
df['elev'] = df['elev'].fillna(0) #If we have a 'NaN', convert it to zero
df['mph'] = df['mph'].fillna(0) #If we have a 'NaN', convert it to zero
df['dir'] = df['dir'].fillna(0) #If we have a 'NaN', convert it to zero

#Convert to UTC time object.
df['report_at'] = pd.to_datetime(df['report_at']).dt.tz_localize('UTC')

#Time-Delta Setup
df['sntd'] = pd.to_timedelta(df['report_at'].diff(+1),unit ='s') #Creates a time delta collumn
df['sntd'] = df['sntd'] / pd.Timedelta(seconds=1) #Turns it into a float with number of seconds.
df = df.drop(df[df.sntd == 0].index)#Dropping rows in new DF where TD = 0
df['sntd'] = df['sntd'].fillna(0) #If we have a 'NaN', convert it to zero
df.reset_index(drop=True, inplace=True) #We Reset the index numbering so we can itterate through it in next section.

#New Dataframe: We have to create a new pandas dataframe to pull from, Setting up some variables for the next section
elapsetrack = 0 #This tracks how much time has passed in the time delta.
processnum = 0  #This is our processing locations counter.
placepts = [0,] #This creates a list and we want the 1st point and last point included as default.

#Finding the indexes that are x seconds apart.
for index in range(len(df.index)): #Itterate through the list
    if elapsetrack < 60: #Activate if elaspetrack is less than timdiv
        elapsetrack = elapsetrack + int(df.loc[index,'sntd']) #Add number of seconds to elapsetrack
        continue #Go back to top of if statement
    else:
        elapsetrack = int(df.loc[index,'sntd']) #Reset elapsetrack back to td of last rec taken.
        placepts.append(index) #Append to the list
        continue #Go back to top of if statement
        
placepts.sort() #Sorts the list by number order.
dfp = df.loc[placepts] #Makes a new dataframe using the list of records we just created.
dfp.reset_index(inplace=True) #We Reset the index numbering so we can itterate through it in next section.

#User Input for File Name
print('Loaded your file sucessfully.')
pfilename = input('What do you want your placefile to be called?') #File output name
spottername = input('Type in the SN Dot Label you want, ex. Name, Callsign, Team, etc.')

#Setting up outputs
with open(str(pfilename)+".txt", "a") as fout: #Write a new file
    
    #Placefile Header
    fout.write(
        ';This placefile was generated by a python script by James Hyde (wxmeddler@gmail.com), '+
        'originally found at https://github.com/wxmeddler/ \n' +
        'Refresh: 60\n' + 
        'Threshold: 999\n' + 
        'Title:'+ str(pfilename) +'\n' +
        'Font: 1, 11, 0,"Courier New"\n'+
        'IconFile: 1, 22, 22, 11, 11, "http://www.spotternetwork.org/icon/spotternet_new.png"\n' +
        'IconFile: 2, 15, 25, 8, 25, "http://www.spotternetwork.org/icon/arrows.png"\n\n')

    #Itterate through csv file to generate locations
    for index in range(len(dfp)):
        
        currdt = dfp.loc[index,'report_at'] #Take DateTime from CSV
    
        try: #This handles if the the next row doesn't exist for the ending datetime.
            nextdt = dfp.loc[index+1,'report_at'] #Take the next row's DateTime from CSV
        except: #If there is no next row
            nextdt = currdt + datetime.timedelta(minutes=5) #make the next time the current report time plus 5 min
            
        #This is a safety catch; if somehow the two times are the same, add another second.  
        if currdt == nextdt:
            nextdt = nextdt + datetime.timedelta(seconds = 1)
    
        #Object Lat/Lon ; takes and prints the current index / row lat and lon.
        fout.write('Object: '+ str(dfp.loc[index,'lat']) + ',' + str(dfp.loc[index,'lon'])+'\n')
    
        #Timerange ; Spits out the time and next time in iso format
        fout.write('Timerange: '+ str(currdt.strftime('%Y-%m-%dT%H:%M:%SZ '))+ str(nextdt.strftime('%Y-%m-%dT%H:%M:%SZ'))+'\n')
    
        #If not moving, 0.5 mph (within GPS error), then don't need direction arrow.
        if dfp.loc[index,'mph'] < 0.5:
            movin = False
            pass #if we're going zero mph, pass down to next section
        else: #If there is a speed, assign a direction arrow.
            movin = True
            fout.write('Icon: 0,0,'+ str(dfp.loc[index,'dir']) +',2,15,'+'\n')
        
       #Hover Over Icon Text
        if movin == True:
            fout.write('Icon: 0,0,000,1,2,"'+ str(spottername) + '\\n'+
                        'Position Time: '+ str(currdt.strftime('%Y-%m-%d %H:%M:%SZ')) +' UTC\\n'+
                        'Heading:'+ str(dfp.loc[index,'dir']) +' deg.\\n'+
                        'Speed:'+ str(round(dfp.loc[index,'mph'])) +' mph"\n')
        else:
            fout.write('Icon: 0,0,000,1,2,"'+ str(spottername) + '\\n'+
                       'Position Time: '+ str(currdt.strftime('%Y-%m-%d %H:%M:%SZ')) +' UTC"\n')
        
        fout.write('Text: 15, 10, 1,"' + str(spottername) +'"\n')
        fout.write('End:'+'\n\n') #End
        processnum = processnum + 1 #We added a record!
fout.close()
print('It is Done! Your Placefile contains '+ str(processnum)+ ' positions!')
print('Your placefile is now in the same folder as this .py file called '+ str(pfilename)+'.txt')
